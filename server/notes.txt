 - Tab is weird:
   * If we send `echo "\t"\n` in one go, then \a shows up on the line and in
     the output.
   * If we send `echo "\t` and `"\n` separately, then \a shows up on the line
     but not in the output.
   * On the line editor, a \t is turned into spaces and the number of spaces
     changes if you insert characters in front. However, if you, e.g. echo the
     \t, a \t is emitted.
   * Todo: check how this corresponds to pasting these sequences "atomically"
     into a terminal
   * Todo: the above behavior is about sending chars into bash. Is bash doing
     this transformation or is the kernel doing this somewhere? Pumping the
     same chars into `cat` may help answer this.

 - Emulator references:
   * Spec of xterm control sequences:
       http://www.xfree86.org/4.5.0/ctlseqs.html (newer)
       http://invisible-island.net/xterm/ctlseqs/ctlseqs.html
   * http://bjh21.me.uk/all-escapes/all-escapes.txt
   * http://vt100.net/docs/vt100-ug/chapter3.html
   * Relevant standards: ANSI X3.64, ECMA-48
   * `man terminfo` and `infocmp`

 - An interesting example command to run:
     ./main.native tty -term xterm -cwd /tmp -env TERM=xterm -exe /usr/bin/vim -- vim | tee /tmp/x
   I'm unsure why, but vim just continually outputs characters...

 - If you use vt100, it doesn't spew output constantly.

 - Weirdly, if you launch it with no environment, it doesn't do anything for a
   while (a few minutes?). This is weird b/c if I run vim in an actual terminal
   (with all environment variables removed) it runs fine. Maybe bash always
   reexports the 'term' variable? (this should also be easy to check)

 - Here's an example command to run which "works":

   ./main.native tty -cwd "/tmp" -env TERM=xterm -term xterm -exe "/bin/echo" -- "echo" "hello"

 - Here's an example that behaves non-deterministically:

   (exe=nano; term=vt100; ./main.native tty -dim 30x30 -cwd "/tmp" -env TERM=$term -term $term -exe $(which $exe) -- $exe) | tee /tmp/x 2>&1

   Most of the time it hands. Sometimes it gives an "Error opening terminal"
   response, and rarely it actually seem to render nano...

   To investigate, I've been tracing via `dtruss` on OS X. Let's say we want to
   start by trace on a "normal" nano process. First, weirdly, dtruss doesn't
   work on certain executable locations? So first:

   $ cat $(which nano) > /tmp

   Note, `cp` seems to copy some attributes that prevent dtruss from tracing,
   so you really do need to cat (or do some non-vanilla invocation of `cp`).
   Then, we can't just run:

   $ sudo dtruss /tmp/nano 2>/tmp/x

   Because even redirecting stderr is enough to interfere with the execution.

   So we need to attach from a separate shell. But we also need to capture all
   the output. Sigh.

   So this hack seems to work: in one shell run:

   $ bash -c 'sleep 10; exec /tmp/nano'

   And in a separate shell:

   $ sudo dtruss -p $(pgrep -f 'sleep') > /tmp/a 2>&1

   Interestingly, sleeping for less time seems to cause issues?

 - Perhaps useful reference: iTerm2's pty wrapper:
   https://github.com/gnachman/iTerm2/blob/master/sources/PTYTask.m

 - Is xterm's control language fully described by infocmp? I suspect not. For
   one thing, the xterm spec uses "Pm" to denote multiple numeric args
   separated by ";", which doesn't seem like a thing in infocmp.

 - functions and manpages that may be of interest:
    - ioctl's relevant to terminal management: man 4 tty
    - man 4 termios, and tcsetattr (function for setting terminal attributes) for setting the attributes discussed

 - random other note: the `splice` function on linux for moving data w/o going via the kernel
